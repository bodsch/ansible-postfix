#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# (c) 2020, Bodo Schulz <bodo@boone-schulz.de>
# BSD 2-clause (see LICENSE or https://opensource.org/licenses/BSD-2-Clause)

from __future__ import absolute_import, division, print_function
import os
import hashlib
import json

from ansible.module_utils.basic import AnsibleModule
from ansible_collections.bodsch.core.plugins.module_utils.checksum import Checksum
from ansible_collections.bodsch.core.plugins.module_utils.directory import create_directory
from ansible_collections.bodsch.core.plugins.module_utils.template.template import write_template
from ansible_collections.bodsch.core.plugins.module_utils.module_results import results

TPL_BACKEND = """# generated by ansible

{% for key, value in item.items() %}
{{ "{:<40}".format(key) }}  {{ value }}
{% endfor %}
"""


class PostfixMaps(object):
    """
      Main Class
    """
    module = None

    def __init__(self, module):
        """
          Initialize all needed Variables
        """
        self.module = module

        self._postmap = module.get_bin_path('postmap', True)
        self.maps = module.params.get("maps")
        self.cache_directory = "/var/cache/ansible/postfix"

    def run(self):
        """
          runner
        """
        _changed = False
        _failed = True
        _msg = "module init"

        create_directory(self.cache_directory)
        create_directory(os.path.join(self.cache_directory, "maps"))

        self.checksum = Checksum(self.module)

        result_state = []

        for map_data in self.maps:
            """
              - name: sender_canonical_maps
                map_type: "lmdb"
                map_file: "{{ postfix_maps_directory }}/sender_canonical_maps"
                map_vars: "{{ postfix_sender.canonical_maps | default([]) }}"
                postmap: true
            """
            res = {}

            maps_name = map_data.get("name", None)

            valid, _msg = self._validate_map(map_data)

            if valid:
                file_name = map_data.get("map", {}).get("file", None)
                maps_data = map_data.get("map", {}).get("vars", [])
                maps_type = map_data.get("map", {}).get("type", "lmdb")
                run_postmap = map_data.get("postmap", True)

                _failed, _changed, _msg = self._write_template(file_name, maps_data)

                if _changed:
                    if run_postmap and maps_type in ["btree", "cdb", "dbm", "fail", "lmdb", "sdbm"]:
                        args = []
                        args.append(self._postmap)
                        args.append(f"{maps_type}:{file_name}")

                        rc, out, err = self._exec(args)

                res[maps_name] = dict(
                    failed=_failed,
                    changed=_changed,
                    msg=_msg
                )

            else:
                res[maps_name] = dict(
                    failed=True,
                    msg=_msg
                )

            result_state.append(res)

        _state, _changed, _failed, state, changed, failed = results(self.module, result_state)

        result = dict(
            changed = _changed,
            failed = _failed,
            result = result_state
        )

        return result

    def _validate_map(self, map_data):
        """
        """
        valid = False
        msg = "alles ist um seife"

        error_msg = []

        maps_name = map_data.get("name", None)
        maps_data = map_data.get("map", {})

        if not maps_name:
            error_msg.append("name")
            msg = f"ERROR: broken maps definition: {map_data}"

        else:
            if len(maps_data) > 0:
                maps_type = maps_data.get("type", "lmdb")
                maps_file = maps_data.get("file", None)
            else:
                maps_type = "lmdb"
                maps_file = None

            # self.module.log(f"  - type: '{maps_type}'")
            # self.module.log(f"  - file: '{maps_file}'")
            # self.module.log(f"  - vars: '{maps_vars}'")

            if not maps_type or maps_type not in ["btree", "cdb", "dbm", "fail", "lmdb", "sdbm"]:
                error_msg.append("type")
            if not maps_file:
                error_msg.append("file")

            if len(error_msg) > 0:
                msg = f"The variables for '{maps_name}' have not been defined: "
                msg += ", ".join(error_msg)
            else:
                valid = True
                msg = None

        return (valid, msg)

    def _write_template(self, file_name, data):
        """
        """
        if isinstance(data, dict):
            """
                sort data
            """
            data = json.dumps(data, sort_keys=True)
            if isinstance(data, str):
                data = json.loads(data)

        checksum_file = os.path.join(self.cache_directory, "maps", f"{os.path.basename(file_name)}.checksum")

        if not os.path.exists(file_name) and os.path.exists(checksum_file):
            os.remove(checksum_file)

        changed, checksum, old_checksum = self.checksum.validate(
            checksum_file=checksum_file,
            data=data
        )

        if not changed:
            return False, False, "The configuration file has not been changed."

        values = self.map_data(data)

        write_template(file_name, TPL_BACKEND, values)

        self.checksum.write_checksum(
            checksum_file=checksum_file,
            checksum=checksum
        )

        return False, True, "The configuration file was written successfully."

    def map_data(self, data):
        """
            input: [{'virtual': 'webmaster@yourdomain.com', 'alias': 'personal_email@gmail.com'}, {'virtual': 'billandbob@yourdomain.com', 'alias': 'bill@gmail.com, bob@gmail.com'}, {'virtual': 'ann-katrin@yourdomain.com', 'aliases': ['ann@gmail.com', 'bob@gmail.com', 'katrin@gmail.com']}]

            output: {{'webmaster@yourdomain.com': 'personal_email@gmail.com'}, {'billandbob@yourdomain.com': 'bill@gmail.com, bob@gmail.com'}, {'ann-katrin@yourdomain.com': 'ann@gmail.com, bob@gmail.com, katrin@gmail.com'}}
        """
        key = None
        values = None
        result = {}

        if isinstance(data, list):
            for i in data:
                res = {}
                if isinstance(i, dict):
                    key = i[list(i.keys())[0]]
                    values = i[list(i.keys())[1]]
                    if isinstance(values, list):
                        values = ", ".join(values)
                    res.update({key: values})
                result.update(res)

        return result

    def _exec(self, cmd):
        """
        """
        rc, out, err = self.module.run_command(cmd, check_rc=True)

        if rc != 0:
            _out  = out.split("\n")
            _err  = err.split("\n")
            self.module.log(f" - out: '{out}' ({type(out)}) - {len(out)}")
            self.module.log(f" - err: '{err}' ({type(err)}) - {len(err)}")
            self.module.log(f" - out: '{_out}'")
            self.module.log(f" - err: '{_err}'")

        return rc, out, err


# ===========================================
# Module execution.
#


def main():
    """
    """
    args = dict(
        maps=dict(
            required = True,
            type = "list",
        )
    )

    module = AnsibleModule(
        argument_spec=args,
        supports_check_mode=False,
    )

    postmap = PostfixMaps(module)
    result = postmap.run()

    module.log(msg=f"= result: {result}")

    module.exit_json(**result)


# import module snippets
if __name__ == '__main__':
    main()
